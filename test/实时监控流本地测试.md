# 本地实时监控流测试指南

本文档说明如何在同一台机器上用单一 gRPC 端口同时跑服务端与客户端，验证 `StreamMonitoring` 实时监控流与普通 Compute 请求的共存。

## 前置条件
- 已安装依赖并更新到最新 proto 生成代码。
- 已开启资源监控（`ComputeServicer` 默认 `enable_resource_monitoring=True`）。
- 使用默认端口 50052，可自行修改。

## 启动服务端
在一个终端启动服务器（示例用 trunk_server）：
```bash
cd /Users/lhy/Desktop/Git/SL
python test/server/trunk_server.py --port 50052
```
服务器启动后会自动开启 `ServerMonitor`，无需额外配置。

## 启动客户端并同时订阅监控流
新开一个终端，运行交互式客户端并在后台订阅监控流。

### 1) 交互式客户端（正常对话）
```bash
cd /Users/lhy/Desktop/Git/SL
python test/client/interactive_client.py --trunk_server localhost:50052
```
按提示输入文本发起对话。

### 2) 同时订阅监控流
在同一进程里添加如下最小示例（也可在单独脚本/线程运行）：
```python
from splitlearn_comm import GRPCComputeClient
import threading

client = GRPCComputeClient("localhost:50052")
client.connect()

running = True
snapshots = []

def consume():
    for snap in client.stream_monitoring(1.0):  # 1 秒推送一次
        if not running:
            break
        snapshots.append(snap)
        print("[monitor]", snap)

thread = threading.Thread(target=consume, daemon=True)
thread.start()

# 在这里可以继续用 client.compute(...) 或使用 interactive_client 的逻辑
# ...

# 结束时
running = False
client.close()
thread.join()
print(f"共收集 {len(snapshots)} 条快照")
```
说明：
- 同一 channel/端口即可并行 `Compute` 与 `StreamMonitoring`，HTTP/2 自动多路复用。
- 服务端未启用监控时，`StreamMonitoring` 会返回 `FAILED_PRECONDITION`。

## 验证要点
- 服务端日志可看到 `ServerMonitor initialized`。
- 客户端监控流应持续打印 CPU/内存/GPU 等指标。
- 发起对话后，`Compute` 仍正常返回结果，同时监控流不中断。

## 常见问题
- **监控流无数据**：确认服务端启动时未报 “monitoring disabled” 或端口未被占用；采样间隔不要低于 0.1s。
- **连接断开**：网络异常或服务器退出会中断流；可在客户端捕获 `RpcError` 并重连。
- **高频采样开销**：建议 0.5–2 秒；若需更高频率，关注 CPU/带宽占用。

